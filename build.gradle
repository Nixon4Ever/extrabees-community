plugins {
	id('idea')
	id("maven-publish")
	id('com.modrinth.minotaur') version '2.+'
	id('com.matthewprenger.cursegradle') version '1.4.0'
	id "org.jetbrains.gradle.plugin.idea-ext" version "1.1.9"
	id 'net.neoforged.moddev.legacyforge' version '2.0.80'
}

group = "nixon.extrabees"
version = extrabeesVersion

java.toolchain.languageVersion = JavaLanguageVersion.of(17)

legacyForge {
	version = "1.20.1-$forgeVersion"

	accessTransformers = files('src/main/resources/META-INF/accesstransformer.cfg')
	// Set to false because Forge has broken access transformers
	//validateAccessTransformers = true

	// Add Parchment parameter mappings
	parchment {
		mappingsVersion = project.mappingsVersion
		minecraftVersion = project.minecraftVersion
	}

	runs {
		configureEach {
			logLevel = org.slf4j.event.Level.DEBUG
			jvmArgument '-XX:+AllowEnhancedClassRedefinition'
			jvmArgument '-XX:+IgnoreUnrecognizedVMOptions'
		}

		client {
			client()
		}

		server {
			server()
			gameDirectory.set(project.layout.projectDirectory.dir('run/server'))
			programArgument '--nogui'
		}
	}

	mods {
		extrabees {
			sourceSet sourceSets.main
		}
	}
}

repositories {
	maven {
		name = 'jei'
		url = 'https://maven.blamejared.com/'
		content { includeGroup "mezz.jei" }
	}
	maven {
		name = "Patchouli"
		url = "https://maven.blamejared.com/"
	}
	maven {
		name = 'Architectury API'
		url = "https://maven.architectury.dev"
		content { includeGroup "dev.architectury" }
	}
	maven {
		name = 'KubeJS and Rhino'
		url = "https://maven.saps.dev/minecraft"
		content { includeGroup "dev.latvian.mods" }
	}
	maven {
		name = 'Mekanism'
		url = 'https://modmaven.dev/'
		content { includeGroup 'mekanism' }
	}
	maven {
		url "https://cursemaven.com"
		content {
			includeGroup "curse.maven"
		}
	}
	maven {
		name = 'ModKit'
		url 'https://jitpack.io'
		content { includeGroup 'com.github.thedarkcolour' }
	}
	exclusiveContent {
		forRepository {
			maven {
				name = "Modrinth"
				url = "https://api.modrinth.com/maven"
			}
		}
		filter {
			includeGroup "maven.modrinth"
		}
	}
}

dependencies {
	// JEI OPTIONAL
	modCompileOnly "mezz.jei:jei-$minecraftVersion-common-api:$jeiVersion"
	modCompileOnly "mezz.jei:jei-$minecraftVersion-forge-api:$jeiVersion"
	modRuntimeOnly "mezz.jei:jei-$minecraftVersion-forge:$jeiVersion"
	// KubeJS OPTIONAL
	modImplementation "dev.architectury:architectury-forge:${architectury_version}"
	modImplementation "dev.latvian.mods:rhino-forge:${rhino_version}"
	modImplementation "dev.latvian.mods:kubejs-forge:${kubejs_version}"
	// PATCHOULI REQUIRED
	modCompileOnly "vazkii.patchouli:Patchouli:$patchouliVersion-FORGE:api"
	modRuntimeOnly "vazkii.patchouli:Patchouli:$patchouliVersion-FORGE"
	// FORESTRY REQUIRED
	modImplementation "maven.modrinth:forestry-community-edition:$forestryVersion"

	// COFH OPTIONAL
	modImplementation "maven.modrinth:cofh-core:$COFHVersion"
	// Thermal foundation OPTIONAL
	modImplementation "maven.modrinth:thermal-foundation:$ThermalFoundationVersion"

	// Mekanism OPTIONAL
	modImplementation "maven.modrinth:mekanism:$MekanismVersion"

	// zerocore OPTIONAL
	modImplementation "maven.modrinth:zerocore:$ZeroCoreVersion"
	// Extreme reactors OPTIONAL
	modImplementation "maven.modrinth:extreme-reactors:$ExtremereactorsVersion"

	// ModKit DEV ONLY
	modImplementation 'com.github.thedarkcolour:ModKit:0302f9aa42'

	// DEV ONLY
	compileOnly "org.jetbrains:annotations:23.0.0"
}

sourceSets.main.resources { srcDir 'src/generated/resources' }

var generateModMetadata = tasks.register("generateModMetadata", ProcessResources) {
	var replaceProperties = [
			"version": project.version,
			"forgeVersionRange": forgeVersionRange,
			"jeiVersionRange": jeiVersionRange,
			"patchouliVersionRange": patchouliVersionRange,
			"fmlVersionRange": fmlVersionRange,
			"forestryVersionRange": forestryVersionRange,
	]
	inputs.properties replaceProperties
	expand replaceProperties

	from "src/main/templates"
	into "build/generated/sources/modMetadata"
}
sourceSets.main.resources.srcDir generateModMetadata

idea.project.settings {
	taskTriggers {
		afterSync generateModMetadata
	}
}

jar {
	from sourceSets.main.output.classesDirs
	from sourceSets.main.output.resourcesDir

	manifest {
		attributes([
				"Specification-Title"     : "ExtraBees",
				"Specification-Vendor"    : "Nixon",
				"Specification-Version"   : "${project.version}",
				"Implementation-Title"    : "${project.name}",
				"Implementation-Version"  : "${project.version}",
				"Implementation-Vendor"   : "Nixon",
				"Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
		])
	}
}

tasks.withType(JavaCompile).configureEach {
	options.encoding = "UTF-8"
	options.compilerArgs << "-Xmaxerrs" << "400"
}

idea {
	module {
		downloadSources = true
		downloadJavadoc = true
	}
}

javadoc {
	source = sourceSets.main.allJava
	classpath = sourceSets.main.compileClasspath + sourceSets.main.output

	options.addStringOption("Xdoclint:none", "-quiet")
	options.encoding = "UTF-8"

	include "extrabees/api/**"
}

tasks.register('javadocJar', Jar) {
	dependsOn javadoc
	archiveClassifier.set("javadoc")
	from javadoc.destinationDir
}

tasks.register('sourcesJar', Jar) {
	archiveClassifier.set("sources")
	from sourceSets.main.allJava
}

tasks.register('apiJar', Jar) {
	archiveClassifier.set("api")
	// api jar ist just a development aid and serves as both a binary and source jar simultaneously
	from sourceSets.main.output
	from sourceSets.main.allJava

	include "extrabees/api/**"
}

artifacts {
	archives javadocJar
	archives sourcesJar
	archives apiJar
}

publishing {
	afterEvaluate {
		publications {
			mavenJava(MavenPublication) {
				groupId = project.group
				artifactId = project.archivesBaseName
				version = project.version

				// ForgeGradle will generate wild dependency definitions, see https://github.com/MinecraftForge/ForgeGradle/issues/584
				// Since we don't actually depend on anything, just remove the entire node.
				pom.withXml {
					asNode().remove(asNode().dependencies)
				}

				from components.java
				artifact sourcesJar
				artifact javadocJar
				artifact apiJar
			}
		}
	}

	repositories {
		maven {
			def releasesRepoUrl = uri("$buildDir/repos/releases")
			def snapshotsRepoUrl = uri("$buildDir/repos/snapshots")

			name = "Project"
			url = version.toString().endsWith("SNAPSHOT") ? snapshotsRepoUrl : releasesRepoUrl
		}

		maven {
			credentials {
				username System.getenv("MODMAVEN_USER")
				password System.getenv("MODMAVEN_PASSWORD")
			}

			name = "Modmaven"
			url = "https://modmaven.dev/artifactory/local-releases/"
		}
	}
}

if (System.getenv("CURSEFORGE_TOKEN")) {
	curseforge {
		apiKey = System.getenv("CURSEFORGE_TOKEN")

		project {
			id = project.curseforgeId
			changelogType = "markdown"
			changelog = getChangelog(version)

			releaseType = "release"

			addGameVersion(project.minecraftVersion)
			addGameVersion("Forge")
			addGameVersion("Java 17")

			mainArtifact(reobfJar.archiveFile) {
				displayName = "Forestry: Community Edition ${project.version}"
				relations {
					optionalDependency 'jei'
					requiredDependency 'patchouli'
				}
			}
		}
	}
}

modrinth {
	token = System.getenv("MODRINTH_TOKEN")
    projectId = project.modrinthId
	versionName = "Forestry: Community Edition $version"
	versionNumber = version.toString()
	versionType = "release"
	gameVersions = [minecraftVersion]
	loaders = ["forge"]
	changelog = getChangelog(project.version)

	uploadFile = reobfJar
	additionalFiles.add(sourcesJar)
	additionalFiles.add(apiJar)
	additionalFiles.add(javadocJar)

	dependencies {
		optional.project("jei")
		required.project("patchouli")
	}
}

static def getChangelog(Object version) {
	version = version.toString()

	def file = new File('changelog.md')
	if (!file.exists()) {
		return "Changelog file not found"
	}

	// Relies on the changelog block being "##blahblahblah_VERSION" where _ is a space
	def content = file.text.normalize().split("##.* ")

	for (final def chunk in content) {
		if (chunk.isEmpty()) continue

		def lineTerminatorIndex = chunk.findIndexOf { c -> c == '\n' || c == '\r' }
		def versionString = chunk.substring(0, lineTerminatorIndex)

		if (versionString == version) {
			return "## Forestry $version\n" + chunk.substring(lineTerminatorIndex + 1)
		}
	}

	// Fallback in case this fails
	return "Forestry Update ${version}"
}